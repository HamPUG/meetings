This talk started out with a discussion with Peter and Ian over the behaviour of typing “help(modules)” into the Python REPL. This is supposed to collect and summarize the help docstrings for all the modules installed on your system. On some machines, this would hang and never complete. On my machine, it would complete and display results. but then when I tried to exit the REPL, it would hang.

The thing is, when you import a Python module, it is actually executing the contents of the module. So the code can perform arbitrary operations, beyond merely declaring things, even before you actually try to c make use of anything from that module. I think in my case a module which was only supposed to be imported for testing purposes was spawning a subprocess, and on exit it was waiting for this subprocess to exit, but the subprocess was still awaiting instructions on what it was supposed to do. Hence, deadlock.

So this got me to thinking: what would be safer way of loading a module, if all you want to do is find out what it does? Obviously you couldn’t show the complete contents without a full import, but you could at least load and show the module docstring.

It turns out this is quite easy to do, thanks to the standard “ast” module <https://docs.python.org/3/library/ast.html>. An Abstract Syntax Tree is an intermediate representation of your Python source code, generated by the compiler as part of the process of translating it into executable code. It represents the structure of your program, with details like the layout of your program text, which are irrelevant to code generation, removed (or actually hidden away, so they can be retrieved for reporting compilation errors). And what this module does is expose that compiler function for your own use.

I was particularly intrigued to see the “get_docstring” function, which was exactly what I wanted. So what I can do is read the .py file containing the module source, and put it through ast.parse(). Then I can call the get_docstring() method on the resulting object, and there’s the top-level module help.

(Show get_module_comment script at this point. Mention that pyclbr <https://docs.python.org/3/library/pyclbr.html> might offer a nicer way of doing it? Specifically designed to retrieve what information it can just from parsing the module, not by actually running it.)

So Peter asked me to talk about this, and all the other fun you can have with ASTs. So I had a look, to see what other interesting stuff I could come up with, and came to the conclusion that ASTs themselves are a bit limited, unless you want to get into more advanced things like implementing a syntax-level macro facility. So I thought it would be more useful to broaden the subject of the talk a bit, and go into some detail on some of the other modules available in the “Language Services” section <https://docs.python.org/3/library/language.html>.

Note the warnings about the code-generation features: there are no guarantees that these will remain substantially unchanged from one CPython version to the next. So don’t rely too much on these details in important libraries or scripts.

Besides ASTs, there are also these things called “code objects”. The built-in “compile()” function <https://docs.python.org/3/library/functions.html#compile> can generate these from source code or from an AST. And eval() and exec() can run code objects, as an alternative to being given a source code string.

(at this point, would run the sample_function script, instead this is now the “ASTs & Other Python Language Services” notebook.)

Here’s what the AST from the sample_function looks like (at least in Python 3.10), reformatted for clarity:

Module \
  (
    body=
        [
            FunctionDef
              (
                name='mymax',
                args=arguments
                  (
                    posonlyargs=[],
                    args=
                      [
                        arg(arg='a', annotation=Name(id='int', ctx=Load())),
                        arg(arg='b', annotation=Name(id='int', ctx=Load()))
                      ],
                    kwonlyargs=[],
                    kw_defaults=[],
                    defaults=[]
                  ),
                body=
                  [
                    Expr
                      (
                        value=Constant
                          (
                            value='sample function to see what compilation and disassembly look like.'
                          )
                      ),
                    If
                      (
                        test=Compare
                          (
                            left=Name(id='a', ctx=Load()),
                            ops=[Gt()],
                            comparators=[Name(id='b', ctx=Load())]
                          ),
                        body=[Return(value=Name(id='a', ctx=Load()))],
                        orelse=[Return(value=Name(id='b', ctx=Load()))]
                      )
                  ],
                decorator_list=[],
                returns=Name(id='int', ctx=Load())
              )
        ],
    type_ignores=[]
  )

Consider the “inspect” module <https://docs.python.org/3/library/inspect.html> is one I have used more than once. Among other things, it lets you retrieve the source code from a function, class, module or whatever.

For an example use, I set myself the task of recreating this page <https://www.cairographics.org/samples/> of code snippets using the Cairo graphics library and the output they generate, except that the code would be translated to Python and use my Qahirah binding for Cairo.

So in my version, each snippet becomes a Python function. I get the source of the function, strip off the “def” line (and some initial indentation), and render the rest as lines of text alongside the output from calling the function.

So then I looked a little bit into implementing a syntax-level macro facility, which I said above I wouldn’t do. And it turns out it’s not that mind-boggling. I won’t bother offering a finished product, but I can go into some detail into how it would work with a simple example.

(Look at “AST-Based Syntax Macros” notebook.)
