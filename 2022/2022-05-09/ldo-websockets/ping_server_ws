#!/usr/bin/python3
#+
# Example WebSocket server, making direct use of the python3-websockets
# package. See accompanying README for an explanation.
#
# Copyright 2022 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>. This
# script is licensed CC0
# <https://creativecommons.org/publicdomain/zero/1.0/>; do with it
# what you will.
#-

import sys
import os
import enum
import socket
import subprocess
import asyncio
import logging
import websockets
import websockets.exceptions

LOGGING_NAME = "ping_server"
  # identifies my messages in the logging module

class WEBSOCK_CLOSE(enum.IntEnum) :
    "some useful WebSocket codes to use on connection close."
    # codes come from RFC6455 <https://www.rfc-editor.org/rfc/rfc6455>
    NORMAL = 1000
    DATA_ERROR = 1003
    WTF = 1011 # Weird Technical Failure
#end WEBSOCK_CLOSE

SUPPORTED_PROTOCOL = "pingu.example.com"

def get_logger() :
    logger = logging.getLogger(LOGGING_NAME)
    try :
        loglevel = int(os.getenv("LOGLEVEL", ""))
        if loglevel < 0 :
            raise ValueError("invalid loglevel")
        #end if
    except ValueError :
        loglevel = None
    #end try
    logging.basicConfig(level = loglevel)
    return \
        logger
#end get_logger

logger = get_logger()

async def handle_conn(conn, *ignore) :
    # older versions call me with second arg, being the path.
    logger.debug \
      (
            "connection from %s, path = %s, request_headers = %s"
        %
            (repr(conn.remote_address), conn.path, repr(conn.request_headers))
      )
    child = None
    try :
        while True :
            try :
                data = await conn.recv()
            except websockets.exceptions.ConnectionClosedOK :
                break
            #end try
            if isinstance(data, str) :
                logger.info("request to ping %s" % repr(data))
                try :
                    target = socket.gethostbyname(data)
                      # note: blocking call
                except (UnicodeError, OSError) as err :
                    logger.info("error translating target %s: %s" % (repr(data), repr(err)))
                    target = None
                #end try
                if target != None :
                    child = await asyncio.create_subprocess_exec \
                      (
                        "ping", "-c", "10", "-i", "2", target,
                        stdin = subprocess.DEVNULL,
                        stdout = subprocess.PIPE
                      )
                    nextline = asyncio.create_task(child.stdout.readline())
                    child_done = asyncio.create_task(child.wait())
                    while True :
                        await asyncio.wait \
                          (
                            [nextline, child_done],
                            return_when = asyncio.FIRST_COMPLETED
                          )
                        if nextline.done() :
                            failure = nextline.exception()
                            if failure != None :
                                result = str(failure)
                            else :
                                line = nextline.result()
                                result = line.decode()
                            #end if
                            await conn.send(result)
                            nextline = None
                        #end if
                        if child_done.done() :
                            sts = child.returncode
                            child = None
                            if sts != 0 :
                                logger.warning("child terminated with status %d" % sts)
                                closecode = WEBSOCK_CLOSE.WTF
                            else :
                                closecode = WEBSOCK_CLOSE.NORMAL
                            #end if
                            await conn.close(code = closecode)
                            logger.info("end request to ping %s" % repr(target))
                            break
                        #end if
                        assert nextline == None
                        nextline = asyncio.create_task(child.stdout.readline())
                    #end while
                else :
                    await conn.close(code = WEBSOCK_CLOSE.DATA_ERROR)
                #end if
            else :
                await conn.close(code = WEBSOCK_CLOSE.DATA_ERROR)
                break
            #end if
        #end while
    except websockets.exceptions.ConnectionClosedError as err :
        logger.warning("connection unexpectedly closed: %s" % repr(err))
    #end try
    if child != None :
        child.kill()
    #end if
#end handle_conn

async def main() :
    listen = await websockets.serve(handle_conn, host = "127.0.0.1", port = 9370, subprotocols = [SUPPORTED_PROTOCOL])
    await listen.server.serve_forever()
#end main

asyncio.run(main())
